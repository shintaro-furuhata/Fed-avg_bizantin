
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>bizantin05</title><meta name="generator" content="MATLAB 9.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2025-08-13"><meta name="DC.source" content="bizantin05.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="comment">% =========================</span>
<span class="comment">% &#12497;&#12521;&#12513;&#12540;&#12479;&#35373;&#23450;</span>
<span class="comment">% =========================</span>
K = 30;         <span class="comment">% &#12463;&#12521;&#12452;&#12450;&#12531;&#12488;&#25968;</span>
alpha = 1;      <span class="comment">% &#12473;&#12486;&#12483;&#12503;&#12469;&#12452;&#12474;</span>
mu = 0.01;      <span class="comment">% &#23398;&#32722;&#29575;</span>
tau = -2;       <span class="comment">% &#25552;&#26696;&#25163;&#27861;&#12398;&#38334;&#20516;</span>
epochs = 1000;  <span class="comment">% &#12456;&#12509;&#12483;&#12463;&#25968;</span>
detect_epochs = 500; <span class="comment">% &#25915;&#25731;&#26908;&#20986;&#12501;&#12455;&#12540;&#12474;</span>
acc_threshold_ratio = 0.98; <span class="comment">% &#26908;&#20986;&#22522;&#28310;&#65288;&#21106;&#21512;&#65289;</span>
attacker_ratio = 1/3; <span class="comment">% &#25915;&#25731;&#32773;&#21106;&#21512;</span>

<span class="comment">% =========================</span>
<span class="comment">% MNIST&#12487;&#12540;&#12479;&#35501;&#12415;&#36796;&#12415; (0&#12392;1&#12398;&#12415;)</span>
<span class="comment">% =========================</span>
[XTrain, YTrain] = digitTrain4DArrayData;
idx = (YTrain == <span class="string">'0'</span>) | (YTrain == <span class="string">'1'</span>);
X = reshape(XTrain(:,:,:,idx), [], sum(idx))';
Y = double(YTrain(idx) == <span class="string">'1'</span>);

<span class="comment">% =========================</span>
<span class="comment">% &#26465;&#20214;A/B/C&#12398;&#12523;&#12540;&#12503;</span>
<span class="comment">% =========================</span>
conditions = {<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>};
results_acc = cell(1, length(conditions));

<span class="keyword">for</span> cond_idx = 1:length(conditions)
    cond = conditions{cond_idx};
    fprintf(<span class="string">"\n=== &#26465;&#20214;%s &#38283;&#22987; ===\n"</span>, cond);

    <span class="comment">% IID&#20998;&#21106;</span>
    N = size(X,1);
    perm = randperm(N);
    X = X(perm,:);
    Y = Y(perm);
    data_per_client = floor(N/K);
    <span class="keyword">for</span> k = 1:K
        idk = (k-1)*data_per_client + 1 : k*data_per_client;
        X_clients{k} = X(idk,:);
        Y_clients{k} = Y(idk);
    <span class="keyword">end</span>

    <span class="comment">% &#25915;&#25731;&#32773;&#35373;&#23450;</span>
    attackers = randperm(K, floor(K * attacker_ratio));
    fprintf(<span class="string">"&#23455;&#38555;&#12398;&#25915;&#25731;&#32773;: %s\n"</span>, mat2str(attackers));
    fprintf(<span class="string">"&#27491;&#35215;&#12463;&#12521;&#12452;&#12450;&#12531;&#12488;: %s\n"</span>, mat2str(setdiff(1:K, attackers)));

    <span class="comment">% &#37325;&#12415;&#21021;&#26399;&#21270;</span>
    w_global = zeros(size(X,2),1);
    detected_attackers = [];
    suspect_counts = zeros(K,1); <span class="comment">% &#26465;&#20214;C&#29992;</span>

    acc_history = zeros(1, epochs);

    <span class="keyword">for</span> epoch = 1:epochs
        grads = zeros(size(X,2), K);
        acc_clients = zeros(1, K);

        <span class="comment">% &#21508;&#12463;&#12521;&#12452;&#12450;&#12531;&#12488;&#26356;&#26032;</span>
        <span class="keyword">for</span> k = 1:K
            Xk = X_clients{k};
            Yk = Y_clients{k};

            <span class="comment">% &#31934;&#24230;&#35336;&#31639;</span>
            pred_labels = double((Xk * w_global) &gt;= 0);
            acc_clients(k) = mean(pred_labels == Yk) * 100;

            <span class="comment">% &#21246;&#37197;&#35336;&#31639;</span>
            pred = 1 ./ (1 + exp(-Xk * w_global));
            grad = Xk' * (pred - Yk) / size(Xk,1);

            <span class="comment">% &#25915;&#25731;&#32773;&#12398;&#25369;&#21205;&#12392;&#26908;&#20986;&#24460;&#12398;&#21453;&#36578;&#12398;&#21453;&#36578;&#65288;&#26465;&#20214;B/C&#65289;</span>
            <span class="keyword">if</span> cond == <span class="string">"B"</span>
                <span class="keyword">if</span> ismember(k, attackers)
                    grad = -grad; <span class="comment">% &#25915;&#25731;&#32773;&#12399;&#24120;&#12395;&#21453;&#36578;</span>
                <span class="keyword">end</span>
            <span class="keyword">elseif</span> cond == <span class="string">"C"</span>
                <span class="keyword">if</span> ismember(k, attackers)
                    grad = -grad; <span class="comment">% &#25915;&#25731;&#32773;&#12399;&#26908;&#20986;&#21069;&#12399;&#21453;&#36578;&#25915;&#25731;</span>
                <span class="keyword">end</span>
                <span class="keyword">if</span> epoch &gt; detect_epochs &amp;&amp; ismember(k, detected_attackers)
                    grad = -grad; <span class="comment">% &#26908;&#20986;&#24460;&#12399;&#26908;&#20986;&#12373;&#12428;&#12383;&#25915;&#25731;&#32773;&#12384;&#12369;&#21453;&#36578;&#12398;&#21453;&#36578;&#65288;&#27491;&#24120;&#21270;&#65289;</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            grads(:,k) = grad;
        <span class="keyword">end</span>

        <span class="comment">% &#26465;&#20214;C: &#25915;&#25731;&#26908;&#20986;&#20966;&#29702;</span>
        <span class="keyword">if</span> cond == <span class="string">"C"</span>
            <span class="keyword">if</span> epoch &lt;= detect_epochs
                cos_sims = zeros(K,K);
                <span class="keyword">for</span> i = 1:K
                    <span class="keyword">for</span> j = 1:K
                        <span class="keyword">if</span> i ~= j
                            g_i = grads(:,i);
                            g_j = grads(:,j);
                            <span class="keyword">if</span> norm(g_i) ~= 0 &amp;&amp; norm(g_j) ~= 0
                                cos_sims(i,j) = (g_i' * g_j) / (norm(g_i) * norm(g_j));
                            <span class="keyword">end</span>
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>

                <span class="keyword">for</span> i = 1:K
                    sum_cos = sum(cos_sims(i,:));
                    <span class="keyword">if</span> sum_cos &lt;= tau
                        suspect_counts(i) = suspect_counts(i) + 1;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>

                <span class="keyword">if</span> epoch == detect_epochs
                    detected_attackers = find(suspect_counts &gt;= acc_threshold_ratio * detect_epochs);
                    fprintf(<span class="string">"&#26465;&#20214;C &#26908;&#20986;&#12373;&#12428;&#12383;&#25915;&#25731;&#32773;: %s\n"</span>, mat2str(detected_attackers));
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">% &#21246;&#37197;&#38598;&#32004;&#12539;&#12514;&#12487;&#12523;&#26356;&#26032;</span>
        global_grad = mean(grads, 2);
        w_global = w_global - mu * global_grad;

        <span class="comment">% &#35352;&#37682;</span>
        acc_history(epoch) = mean(acc_clients);

        <span class="comment">% &#12525;&#12464;</span>
        <span class="keyword">if</span> mod(epoch,100) == 0 || epoch == epochs
            fprintf(<span class="string">"&#26465;&#20214;%s Epoch %d: &#31934;&#24230; %.2f%%\n"</span>, <span class="keyword">...</span>
                cond, epoch, acc_history(epoch));
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    results_acc{cond_idx} = acc_history;
<span class="keyword">end</span>

<span class="comment">% =========================</span>
<span class="comment">% &#12464;&#12521;&#12501;&#25551;&#30011;&#65288;&#31934;&#24230;&#25512;&#31227;&#12398;&#12415;&#65289;</span>
<span class="comment">% =========================</span>
figure;
hold <span class="string">on</span>;
colors = {<span class="string">'b'</span>,<span class="string">'r'</span>,<span class="string">'g'</span>};
<span class="keyword">for</span> i = 1:length(conditions)
    plot(1:epochs, results_acc{i}, <span class="string">'LineWidth'</span>, 1.5, <span class="string">'Color'</span>, colors{i});
<span class="keyword">end</span>
xlabel(<span class="string">'Epoch'</span>);
ylabel(<span class="string">'Accuracy (%)'</span>);
legend(conditions);
title(<span class="string">'&#31934;&#24230;&#25512;&#31227;'</span>);
grid <span class="string">on</span>;
</pre><pre class="codeoutput">
=== &#26465;&#20214;A &#38283;&#22987; ===
&#23455;&#38555;&#12398;&#25915;&#25731;&#32773;: [27 12 29 23 8 10 28 26 20 14]
&#27491;&#35215;&#12463;&#12521;&#12452;&#12450;&#12531;&#12488;: [1 2 3 4 5 6 7 9 11 13 15 16 17 18 19 21 22 24 25 30]
&#26465;&#20214;A Epoch 100: &#31934;&#24230; 90.51%
&#26465;&#20214;A Epoch 200: &#31934;&#24230; 91.72%
&#26465;&#20214;A Epoch 300: &#31934;&#24230; 92.32%
&#26465;&#20214;A Epoch 400: &#31934;&#24230; 92.83%
&#26465;&#20214;A Epoch 500: &#31934;&#24230; 93.23%
&#26465;&#20214;A Epoch 600: &#31934;&#24230; 93.74%
&#26465;&#20214;A Epoch 700: &#31934;&#24230; 94.14%
&#26465;&#20214;A Epoch 800: &#31934;&#24230; 94.44%
&#26465;&#20214;A Epoch 900: &#31934;&#24230; 94.55%
&#26465;&#20214;A Epoch 1000: &#31934;&#24230; 94.65%

=== &#26465;&#20214;B &#38283;&#22987; ===
&#23455;&#38555;&#12398;&#25915;&#25731;&#32773;: [4 18 25 26 14 17 7 28 21 8]
&#27491;&#35215;&#12463;&#12521;&#12452;&#12450;&#12531;&#12488;: [1 2 3 5 6 9 10 11 12 13 15 16 19 20 22 23 24 27 29 30]
&#26465;&#20214;B Epoch 100: &#31934;&#24230; 77.58%
&#26465;&#20214;B Epoch 200: &#31934;&#24230; 83.94%
&#26465;&#20214;B Epoch 300: &#31934;&#24230; 86.26%
&#26465;&#20214;B Epoch 400: &#31934;&#24230; 87.68%
&#26465;&#20214;B Epoch 500: &#31934;&#24230; 88.18%
&#26465;&#20214;B Epoch 600: &#31934;&#24230; 88.08%
&#26465;&#20214;B Epoch 700: &#31934;&#24230; 88.28%
&#26465;&#20214;B Epoch 800: &#31934;&#24230; 88.59%
&#26465;&#20214;B Epoch 900: &#31934;&#24230; 88.69%
&#26465;&#20214;B Epoch 1000: &#31934;&#24230; 88.79%

=== &#26465;&#20214;C &#38283;&#22987; ===
&#23455;&#38555;&#12398;&#25915;&#25731;&#32773;: [8 2 26 30 3 5 12 11 4 18]
&#27491;&#35215;&#12463;&#12521;&#12452;&#12450;&#12531;&#12488;: [1 6 7 9 10 13 14 15 16 17 19 20 21 22 23 24 25 27 28 29]
&#26465;&#20214;C Epoch 100: &#31934;&#24230; 63.03%
&#26465;&#20214;C Epoch 200: &#31934;&#24230; 71.82%
&#26465;&#20214;C Epoch 300: &#31934;&#24230; 76.67%
&#26465;&#20214;C Epoch 400: &#31934;&#24230; 79.29%
&#26465;&#20214;C &#26908;&#20986;&#12373;&#12428;&#12383;&#25915;&#25731;&#32773;: [2;3;4;5;8;11;12;18;26;30]
&#26465;&#20214;C Epoch 500: &#31934;&#24230; 80.81%
&#26465;&#20214;C Epoch 600: &#31934;&#24230; 91.52%
&#26465;&#20214;C Epoch 700: &#31934;&#24230; 92.32%
&#26465;&#20214;C Epoch 800: &#31934;&#24230; 92.73%
&#26465;&#20214;C Epoch 900: &#31934;&#24230; 93.33%
&#26465;&#20214;C Epoch 1000: &#31934;&#24230; 93.43%
</pre><img vspace="5" hspace="5" src="bizantin05_01.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2022b</a><br></p></div><!--
##### SOURCE BEGIN #####
% =========================
% パラメータ設定
% =========================
K = 30;         % クライアント数
alpha = 1;      % ステップサイズ
mu = 0.01;      % 学習率
tau = -2;       % 提案手法の閾値
epochs = 1000;  % エポック数
detect_epochs = 500; % 攻撃検出フェーズ
acc_threshold_ratio = 0.98; % 検出基準（割合）
attacker_ratio = 1/3; % 攻撃者割合

% =========================
% MNISTデータ読み込み (0と1のみ)
% =========================
[XTrain, YTrain] = digitTrain4DArrayData;
idx = (YTrain == '0') | (YTrain == '1');
X = reshape(XTrain(:,:,:,idx), [], sum(idx))';
Y = double(YTrain(idx) == '1');

% =========================
% 条件A/B/Cのループ
% =========================
conditions = {'A','B','C'};
results_acc = cell(1, length(conditions));

for cond_idx = 1:length(conditions)
    cond = conditions{cond_idx};
    fprintf("\n=== 条件%s 開始 ===\n", cond);

    % IID分割
    N = size(X,1);
    perm = randperm(N);
    X = X(perm,:);
    Y = Y(perm);
    data_per_client = floor(N/K);
    for k = 1:K
        idk = (k-1)*data_per_client + 1 : k*data_per_client;
        X_clients{k} = X(idk,:);
        Y_clients{k} = Y(idk);
    end
    
    % 攻撃者設定
    attackers = randperm(K, floor(K * attacker_ratio));
    fprintf("実際の攻撃者: %s\n", mat2str(attackers));
    fprintf("正規クライアント: %s\n", mat2str(setdiff(1:K, attackers)));

    % 重み初期化
    w_global = zeros(size(X,2),1);
    detected_attackers = [];
    suspect_counts = zeros(K,1); % 条件C用

    acc_history = zeros(1, epochs);

    for epoch = 1:epochs
        grads = zeros(size(X,2), K);
        acc_clients = zeros(1, K);

        % 各クライアント更新
        for k = 1:K
            Xk = X_clients{k};
            Yk = Y_clients{k};

            % 精度計算
            pred_labels = double((Xk * w_global) >= 0);
            acc_clients(k) = mean(pred_labels == Yk) * 100;

            % 勾配計算
            pred = 1 ./ (1 + exp(-Xk * w_global));
            grad = Xk' * (pred - Yk) / size(Xk,1);

            % 攻撃者の挙動と検出後の反転の反転（条件B/C）
            if cond == "B"
                if ismember(k, attackers)
                    grad = -grad; % 攻撃者は常に反転
                end
            elseif cond == "C"
                if ismember(k, attackers)
                    grad = -grad; % 攻撃者は検出前は反転攻撃
                end
                if epoch > detect_epochs && ismember(k, detected_attackers)
                    grad = -grad; % 検出後は検出された攻撃者だけ反転の反転（正常化）
                end
            end

            grads(:,k) = grad;
        end

        % 条件C: 攻撃検出処理
        if cond == "C"
            if epoch <= detect_epochs
                cos_sims = zeros(K,K);
                for i = 1:K
                    for j = 1:K
                        if i ~= j
                            g_i = grads(:,i);
                            g_j = grads(:,j);
                            if norm(g_i) ~= 0 && norm(g_j) ~= 0
                                cos_sims(i,j) = (g_i' * g_j) / (norm(g_i) * norm(g_j));
                            end
                        end
                    end
                end

                for i = 1:K
                    sum_cos = sum(cos_sims(i,:));
                    if sum_cos <= tau
                        suspect_counts(i) = suspect_counts(i) + 1;
                    end
                end

                if epoch == detect_epochs
                    detected_attackers = find(suspect_counts >= acc_threshold_ratio * detect_epochs);
                    fprintf("条件C 検出された攻撃者: %s\n", mat2str(detected_attackers));
                end
            end
        end

        % 勾配集約・モデル更新
        global_grad = mean(grads, 2);
        w_global = w_global - mu * global_grad;

        % 記録
        acc_history(epoch) = mean(acc_clients);

        % ログ
        if mod(epoch,100) == 0 || epoch == epochs
            fprintf("条件%s Epoch %d: 精度 %.2f%%\n", ...
                cond, epoch, acc_history(epoch));
        end
    end

    results_acc{cond_idx} = acc_history;
end

% =========================
% グラフ描画（精度推移のみ）
% =========================
figure;
hold on;
colors = {'b','r','g'};
for i = 1:length(conditions)
    plot(1:epochs, results_acc{i}, 'LineWidth', 1.5, 'Color', colors{i});
end
xlabel('Epoch');
ylabel('Accuracy (%)');
legend(conditions);
title('精度推移');
grid on;

##### SOURCE END #####
--></body></html>